import React, { useState, useMemo, useRef, useEffect } from 'react';
import { createRoot } from 'react-dom/client';

// TypeScript-Interface für eine Zeile in der Tabelle
interface TimeSheetRow {
  id: number;
  date: string;
  day: string;
  vmStart: string;
  vmEnd: string;
  nmStart: string;
  nmEnd: string;
  pause: string;
  hours: string;
}

interface LohnRow {
  id: number;
  beschreibung: string;
  menge: string;
  einzelpreis: string;
  gesamt: string;
}

interface MonthSummary {
    hours: string;
    salary: number;
}

type Sheet = 'Zeiterfassung' | 'Lohn' | 'Jahres-Bilanz';

// Hilfsfunktion zur Berechnung der Zeitdifferenz in Minuten
const timeToMinutes = (time: string): number => {
  if (!time || time === '.' || time === '00:00') return 0;
  const parts = time.split(':');
  const hours = Number(parts[0]);
  const minutes = Number(parts[1] || '0');
  if (isNaN(hours) || isNaN(minutes)) {
    return 0;
  }
  return hours * 60 + minutes;
};

// Hilfsfunktion zur Formatierung von Minuten in HH:mm
const minutesToTime = (minutes: number): string => {
  if (isNaN(minutes) || minutes < 0) return '00:00';
  const h = Math.floor(minutes / 60);
  const m = Math.round(minutes % 60);
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
};

// Hilfsfunktion zur kaufmännischen Rundung auf 5 Rappen
const roundToFiveCents = (value: number): number => {
  if (isNaN(value)) return 0;

  // Wert in Rappen umwandeln, um Fliesskomma-Ungenauigkeiten zu vermeiden
  const totalCents = Math.round(value * 100);

  // Letzte Ziffer der Rappen ermitteln
  const lastDigit = totalCents % 10;
  
  let roundedCents;

  // Abrunden bei 1, 2
  if (lastDigit === 1 || lastDigit === 2) {
      roundedCents = totalCents - lastDigit;
  // Aufrunden bei 3, 4
  } else if (lastDigit === 3 || lastDigit === 4) {
      roundedCents = totalCents - lastDigit + 5;
  // 5 beibehalten
  } else if (lastDigit === 5) {
      roundedCents = totalCents;
  // Abrunden bei 6, 7
  } else if (lastDigit === 6 || lastDigit === 7) {
      roundedCents = totalCents - lastDigit + 5;
  // Aufrunden bei 8, 9
  } else if (lastDigit === 8 || lastDigit === 9) {
      roundedCents = totalCents - lastDigit + 10;
  // 0 beibehalten
  } else { // lastDigit ist 0
      roundedCents = totalCents;
  }

  return roundedCents / 100;
};

// Funktion zum Erstellen der initialen Zeilen für den aktuellen Monat
const getInitialRows = (date: Date): TimeSheetRow[] => {
    const year = date.getFullYear();
    const month = date.getMonth();
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const initialRows: TimeSheetRow[] = [];

    for (let day = 1; day <= daysInMonth; day++) {
        const currentDate = new Date(year, month, day);
        const dayOfWeek = currentDate.getDay(); // 0 = Sonntag, 1 = Montag, ..., 6 = Samstag

        // Nur Dienstage (2) und Donnerstage (4) hinzufügen
        if (dayOfWeek === 2 || dayOfWeek === 4) {
             // Musterzeiten definieren
            const vmStart = '';
            const vmEnd = '';
            const nmStart = '';
            const nmEnd = '';

            // Berechnungen durchführen
            const vmStartMins = timeToMinutes(vmStart);
            const vmEndMins = timeToMinutes(vmEnd);
            const nmStartMins = timeToMinutes(nmStart);
            const nmEndMins = timeToMinutes(nmEnd);

            const pauseMins = nmStartMins > vmEndMins ? nmStartMins - vmEndMins : 0;
            const pause = pauseMins > 0 ? minutesToTime(pauseMins) : '.';

            const workVm = vmEndMins > vmStartMins ? vmEndMins - vmStartMins : 0;
            const workNm = nmEndMins > nmStartMins ? nmEndMins - nmStartMins : 0;
            const totalWorkMins = workVm + workNm;
            const hours = totalWorkMins > 0 ? minutesToTime(totalWorkMins) : '.';

            const newRow: TimeSheetRow = {
                id: currentDate.getTime(), // Eindeutige ID basierend auf dem Datum
                date: `${String(day).padStart(2, '0')}.${String(month + 1).padStart(2, '0')}`,
                day: new Intl.DateTimeFormat('de-DE', { weekday: 'short' }).format(currentDate),
                vmStart: vmStart,
                vmEnd: vmEnd,
                nmStart: nmStart,
                nmEnd: nmEnd,
                pause: pause, // Berechnete Pause
                hours: hours, // Berechnete Stunden
            };
            initialRows.push(newRow);
        }
    }
    return initialRows;
};

const getRowsKey = (date: Date) => `arbeitszeiterfassung-data-v2-${date.getFullYear()}-${date.getMonth()}`;
const LEGACY_STORAGE_KEY_ROWS = 'arbeitszeiterfassung-data-v1';

// Hilfsfunktion zur Berechnung des Nettolohns für einen beliebigen Monat
const calculateMonthlyNettolohn = (
    monthRows: TimeSheetRow[],
    hourlyRate: number,
    lohnConfig: LohnRow[]
): number => {
    if (!monthRows || monthRows.length === 0) return 0;

    const totalMinutes = monthRows.reduce((acc, row) => acc + timeToMinutes(row.hours), 0);
    const totalHoursDecimal = totalMinutes / 60;
    const grossSalary = totalHoursDecimal * hourlyRate;

    const feriengeldPercent = parseFloat(lohnConfig[1].einzelpreis.replace(',', '.')) || 0;
    const monatslohn13Percent = parseFloat(lohnConfig[2].einzelpreis.replace(',', '.')) || 0;
    const nbuvPercent = parseFloat(lohnConfig[4].einzelpreis.replace(',', '.')) || 0;
    const krankentaggeldPercent = parseFloat(lohnConfig[5].einzelpreis.replace(',', '.')) || 0;
    
    const feriengeldGesamt = grossSalary * (feriengeldPercent / 100);
    const monatslohn13Gesamt = grossSalary * (monatslohn13Percent / 100);
    const bruttolohn = grossSalary + feriengeldGesamt + monatslohn13Gesamt;

    const nbuvGesamt = bruttolohn * (nbuvPercent / 100);
    const krankentaggeldGesamt = bruttolohn * (krankentaggeldPercent / 100);
    const totalAbzuege = nbuvGesamt + krankentaggeldGesamt;

    const nettolohnRaw = bruttolohn - totalAbzuege;
    return roundToFiveCents(nettolohnRaw);
};

// Diagramm Komponente
const LineChart: React.FC<{ data: number[], labels: string[] }> = ({ data, labels }) => {
    const width = 800;
    const height = 250;
    const padding = 50;

    const maxValue = Math.max(...data, 1000); // Mindestwert, um ein leeres Diagramm zu vermeiden
    const yMax = Math.ceil(maxValue / 1000) * 1000; // Auf den nächsten Tausender aufrunden
    
    const getX = (i: number) => padding + i * (width - 2 * padding) / (data.length - 1);
    const getY = (value: number) => height - padding - (value / yMax) * (height - 2 * padding);

    const pathData = data
        .map((point, i) => `${i === 0 ? 'M' : 'L'} ${getX(i)} ${getY(point)}`)
        .join(' ');
        
    const yAxisGuides = [];
    const numGuides = 5;
    for(let i = 0; i <= numGuides; i++) {
        const value = (yMax / numGuides) * i;
        const y = getY(value);
        yAxisGuides.push(
            <g key={`y-guide-${i}`}>
                <line x1={padding} y1={y} x2={width - padding} y2={y} className="grid-line" />
                <text x={padding - 10} y={y + 5} className="axis-label y-label">{value}</text>
            </g>
        );
    }
    
    return (
        <div className="chart-container">
            <svg viewBox={`0 0 ${width} ${height}`} aria-label="Liniendiagramm des Nettolohns pro Monat">
                <rect width="100%" height="100%" fill="transparent" />
                {yAxisGuides}
                <line x1={padding} y1={height - padding} x2={width - padding} y2={height - padding} className="axis-line" />
                
                {labels.map((label, i) => (
                    <text key={`x-label-${i}`} x={getX(i)} y={height - padding + 20} className="axis-label x-label">{label}</text>
                ))}

                <path d={pathData} className="data-line" fill="none" />
                
                {data.map((point, i) => (
                    point > 0 && <circle key={`dot-${i}`} cx={getX(i)} cy={getY(point)} r="4" className="data-dot" />
                ))}
            </svg>
        </div>
    );
};

// Die Hauptkomponente der Anwendung
const App: React.FC = () => {
  const [currentDate, setCurrentDate] = useState(new Date());

  const [rows, setRows] = useState<TimeSheetRow[]>(() => {
    const key = getRowsKey(currentDate);
    try {
      const savedRows = localStorage.getItem(key);
      if (savedRows) {
        return JSON.parse(savedRows);
      }
      // Migration von altem Schlüssel
      const legacyRows = localStorage.getItem(LEGACY_STORAGE_KEY_ROWS);
      if(legacyRows) {
        localStorage.setItem(key, legacyRows);
        // localStorage.removeItem(LEGACY_STORAGE_KEY_ROWS); // optional: alten Schlüssel entfernen
        return JSON.parse(legacyRows);
      }
    } catch (e) {
      console.error("Fehler beim Laden der Daten aus dem Local Storage", e);
    }
    return getInitialRows(currentDate);
  });
  
  const [activeRowId, setActiveRowId] = useState<number | null>(null);
  const [activeSheet, setActiveSheet] = useState<Sheet>('Zeiterfassung');
  const [hourlyRate] = useState<number>(23.45);

  const [yearlySummary, setYearlySummary] = useState<MonthSummary[]>(() => 
    Array(12).fill({ hours: '00:00', salary: 0 })
  );
  
  const [lohnRows, setLohnRows] = useState<LohnRow[]>(() =>
    Array.from({ length: 10 }, (_, i) => {
      let beschreibung = '';
      let einzelpreis = '';
      if (i === 1) {
          beschreibung = 'Feriengeld';
          einzelpreis = '8.33';
      }
      if (i === 2) {
          beschreibung = '13. Monatslohn';
          einzelpreis = '8.33';
      }
      if (i === 3) {
          beschreibung = 'Bruttolohn';
      }
      if (i === 4) {
          beschreibung = 'NBUV - Beitrag';
          einzelpreis = '1.25';
      }
      if (i === 5) {
          beschreibung = 'Kranken - Taggeld';
          einzelpreis = '0.75';
      }
      if (i === 6) {
          beschreibung = 'Total Abzüge';
      }
      if (i === 7) {
          beschreibung = 'Anzahlung';
      }
      if (i === 8) {
          beschreibung = 'Restzahlung';
      }
      if (i === 9) {
          beschreibung = 'Nettolohn';
      }
      return {
        id: i,
        beschreibung,
        menge: '',
        einzelpreis,
        gesamt: '0.00',
      };
    })
  );

  const fileInputRef = useRef<HTMLInputElement>(null);
  
  // Daten laden, wenn sich der Monat ändert
  useEffect(() => {
    const key = getRowsKey(currentDate);
    try {
        const savedRows = localStorage.getItem(key);
        if (savedRows) {
            setRows(JSON.parse(savedRows));
        } else {
            setRows(getInitialRows(currentDate));
        }
    } catch(e) {
        console.error("Fehler beim Laden der Daten für den neuen Monat", e);
        setRows(getInitialRows(currentDate));
    }
  }, [currentDate]);

  // Daten für den aktuellen Monat speichern, wenn sie sich ändern
  useEffect(() => {
    try {
      const key = getRowsKey(currentDate);
      localStorage.setItem(key, JSON.stringify(rows));
    } catch (e) {
      console.error("Fehler beim Speichern der Daten im Local Storage", e);
    }
  }, [rows, currentDate]);

  const goToPreviousMonth = () => {
    setCurrentDate(prev => new Date(prev.getFullYear(), prev.getMonth() - 1, 1));
  };

  const goToNextMonth = () => {
    setCurrentDate(prev => new Date(prev.getFullYear(), prev.getMonth() + 1, 1));
  };

  // Funktion zur Aktualisierung einer Zeile bei Eingabe
  const handleInputChange = (id: number, field: keyof TimeSheetRow, value: string) => {
    setRows(currentRows =>
      currentRows.map(row => {
        if (row.id === id) {
          let updatedValue = value;

          // Automatische Formatierung für Zeit-Felder (hh:mm)
          if (['vmStart', 'vmEnd', 'nmStart', 'nmEnd'].includes(field)) {
            // Erlaube nur Ziffern und einen Doppelpunkt, um zu verhindern, dass der Cursor springt
            let sanitizedValue = value.replace(/[^0-9:]/g, '');

            // Stelle sicher, dass nur ein Doppelpunkt vorhanden ist
            const colonCount = (sanitizedValue.match(/:/g) || []).length;
            if (colonCount > 1) {
                const firstColonIndex = sanitizedValue.indexOf(':');
                sanitizedValue = sanitizedValue.substring(0, firstColonIndex + 1) + sanitizedValue.substring(firstColonIndex + 1).replace(/:/g, '');
            }

            // Füge automatisch einen Doppelpunkt ein, wenn der Benutzer HHMM eingibt
            const digitsOnly = sanitizedValue.replace(/:/g, '');
            if (digitsOnly.length >= 3 && !sanitizedValue.includes(':')) {
                sanitizedValue = `${digitsOnly.slice(0, 2)}:${digitsOnly.slice(2)}`;
            }
            
            // Begrenze die Länge auf 5 Zeichen (HH:MM)
            updatedValue = sanitizedValue.slice(0, 5);
          }

          const newRow = { ...row, [field]: updatedValue };

          // Tag der Woche aktualisieren, wenn sich das Datum ändert
          if (field === 'date') {
            if (/^\d{1,2}\.\d{1,2}$/.test(updatedValue)) {
                const [day, month] = updatedValue.split('.').map(Number);
                const year = currentDate.getFullYear();
                const date = new Date(year, month - 1, day);
                if (date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day) {
                    newRow.day = new Intl.DateTimeFormat('de-DE', { weekday: 'short' }).format(date);
                } else {
                    newRow.day = 'Ungültig';
                }
             } else {
                newRow.day = '';
             }
          }

          // Berechnungen für Pause und Stunden durchführen
          const vmStartMins = timeToMinutes(newRow.vmStart);
          const vmEndMins = timeToMinutes(newRow.vmEnd);
          const nmStartMins = timeToMinutes(newRow.nmStart);
          const nmEndMins = timeToMinutes(newRow.nmEnd);
          
          const pauseMins = nmStartMins > vmEndMins ? nmStartMins - vmEndMins : 0;
          newRow.pause = pauseMins > 0 ? minutesToTime(pauseMins) : '.';

          const workVm = vmEndMins > vmStartMins ? vmEndMins - vmStartMins : 0;
          const workNm = nmEndMins > nmStartMins ? nmEndMins - nmStartMins : 0;
          const totalWorkMins = workVm + workNm;
          newRow.hours = totalWorkMins > 0 ? minutesToTime(totalWorkMins) : '.';

          return newRow;
        }
        return row;
      })
    );
  };

  const handleKeyDown = (event: React.KeyboardEvent<HTMLInputElement>, currentRowId: number) => {
    if (event.key === 'Enter') {
        event.preventDefault();
        const currentRowIndex = rows.findIndex(row => row.id === currentRowId);

        if (currentRowIndex > -1 && currentRowIndex < rows.length - 1) {
            const nextRow = rows[currentRowIndex + 1];
            // ID des nächsten Eingabefeldes konstruieren und Fokus setzen
            const nextInput = document.getElementById(`vmStart-${nextRow.id}`);
            if (nextInput) {
                nextInput.focus();
            }
        }
    }
  };
  
  const totalHours = useMemo(() => {
    const totalMinutes = rows.reduce((acc, row) => acc + timeToMinutes(row.hours), 0);
    return minutesToTime(totalMinutes);
  }, [rows]);
  
  const totalMinutes = timeToMinutes(totalHours);
  const totalHoursDecimal = totalMinutes / 60;
  const grossSalary = totalHoursDecimal * hourlyRate;

  const downPaymentHoursDecimal = useMemo(() => {
    const totalMinutes = rows.reduce((acc, row) => {
        try {
            const day = parseInt(row.date.split('.')[0], 10);
            if (!isNaN(day) && day >= 1 && day <= 25) {
                return acc + timeToMinutes(row.hours);
            }
        } catch (e) {
            // ignore parsing errors
        }
        return acc;
    }, 0);
    return totalMinutes / 60;
  }, [rows]);

  const handleLohnInputChange = (id: number, field: keyof Omit<LohnRow, 'id' | 'gesamt'>, value: string) => {
    setLohnRows(currentRows => {
        let newRows = currentRows.map(row => {
            if (row.id === id) {
                return { ...row, [field]: value };
            }
            return row;
        });

        // if a user-defined row is changed, calculate its total
        if (id > 5) {
            const changedRow = newRows.find(r => r.id === id)!;
            const menge = parseFloat(changedRow.menge.replace(',', '.')) || 0;
            const einzelpreis = parseFloat(changedRow.einzelpreis.replace(',', '.')) || 0;
            changedRow.gesamt = (menge * einzelpreis).toFixed(2);
        }

        // If Feriengeld or 13. Monatslohn was changed, recalculate them.
        if (id === 1 || id === 2) {
            const grundlohnGesamtVal = parseFloat(newRows.find(r => r.id === 0)?.gesamt.replace(',', '.') || '0');
            const changedRow = newRows.find(r => r.id === id)!;
            const einzelpreis = parseFloat(changedRow.einzelpreis.replace(',', '.') || '0');
            changedRow.menge = grundlohnGesamtVal.toFixed(2);
            changedRow.gesamt = (grundlohnGesamtVal * (einzelpreis / 100)).toFixed(2);
        }

        // If NBUV or Krankentaggeld was changed, recalculate them.
        if (id === 4 || id === 5) {
            const bruttolohnGesamtVal = parseFloat(newRows.find(r => r.id === 3)?.gesamt.replace(',', '.') || '0');
            const changedRow = newRows.find(r => r.id === id)!;
            const einzelpreis = parseFloat(changedRow.einzelpreis.replace(',', '.') || '0');
            changedRow.menge = bruttolohnGesamtVal.toFixed(2);
            changedRow.gesamt = (bruttolohnGesamtVal * (einzelpreis / 100)).toFixed(2);
        }
        
        return newRows;
    });
};

  useEffect(() => {
    setLohnRows(currentRows => {
      const newRows = [...currentRows];
      
      // Grundlohn
      newRows[0] = {
        ...newRows[0],
        beschreibung: 'Grundlohn',
        menge: totalHoursDecimal.toFixed(2),
        einzelpreis: hourlyRate.toFixed(2),
        gesamt: grossSalary.toFixed(2),
      };

      // Feriengeld (id: 1)
      const row2Einzelpreis = parseFloat(newRows[1].einzelpreis.replace(',', '.') || '0');
      newRows[1] = {
        ...newRows[1],
        beschreibung: 'Feriengeld',
        menge: grossSalary.toFixed(2),
        gesamt: (grossSalary * (row2Einzelpreis / 100)).toFixed(2),
      };

      // 13. Monatslohn (id: 2)
      const row3Einzelpreis = parseFloat(newRows[2].einzelpreis.replace(',', '.') || '0');
      newRows[2] = {
        ...newRows[2],
        beschreibung: '13. Monatslohn',
        menge: grossSalary.toFixed(2),
        gesamt: (grossSalary * (row3Einzelpreis / 100)).toFixed(2),
      };

      // Bruttolohn (id: 3)
      const grundlohnGesamt = parseFloat(newRows[0].gesamt) || 0;
      const feriengeldGesamt = parseFloat(newRows[1].gesamt) || 0;
      const monatslohn13Gesamt = parseFloat(newRows[2].gesamt) || 0;
      const bruttolohn = grundlohnGesamt + feriengeldGesamt + monatslohn13Gesamt;
      
      newRows[3] = {
        ...newRows[3],
        beschreibung: 'Bruttolohn',
        menge: '',
        einzelpreis: '',
        gesamt: bruttolohn.toFixed(2),
      };

      // NBUV (id: 4)
      const row4Einzelpreis = parseFloat(newRows[4].einzelpreis.replace(',', '.') || '0');
      newRows[4] = {
          ...newRows[4],
          menge: bruttolohn.toFixed(2),
          gesamt: (bruttolohn * (row4Einzelpreis / 100)).toFixed(2),
      };

      // Krankentaggeld (id: 5)
      const row5Einzelpreis = parseFloat(newRows[5].einzelpreis.replace(',', '.') || '0');
      newRows[5] = {
          ...newRows[5],
          menge: bruttolohn.toFixed(2),
          gesamt: (bruttolohn * (row5Einzelpreis / 100)).toFixed(2),
      };

      // Total Abzüge (id: 6)
      const nbuvGesamt = parseFloat(newRows[4].gesamt) || 0;
      const krankentaggeldGesamt = parseFloat(newRows[5].gesamt) || 0;
      const totalAbzuege = nbuvGesamt + krankentaggeldGesamt;
      
      newRows[6] = {
          ...newRows[6],
          menge: '',
          einzelpreis: '',
          gesamt: totalAbzuege.toFixed(2),
      };

      // Nettolohn (id: 9)
      const nettolohnRaw = bruttolohn - totalAbzuege;
      const nettolohn = roundToFiveCents(nettolohnRaw);
      newRows[9] = {
          ...newRows[9],
          menge: '',
          einzelpreis: '',
          gesamt: nettolohn.toFixed(2),
      };

      // Anzahlung (id: 7)
      const downPaymentGrossSalary = downPaymentHoursDecimal * hourlyRate;
      const downPaymentFeriengeld = downPaymentGrossSalary * (row2Einzelpreis / 100);
      const downPayment13Monatslohn = downPaymentGrossSalary * (row3Einzelpreis / 100);
      const downPaymentBruttolohn = downPaymentGrossSalary + downPaymentFeriengeld + downPayment13Monatslohn;
      const downPaymentNbuv = downPaymentBruttolohn * (row4Einzelpreis / 100);
      const downPaymentKrankentaggeld = downPaymentBruttolohn * (row5Einzelpreis / 100);
      const downPaymentTotalAbzuege = downPaymentNbuv + downPaymentKrankentaggeld;
      const anzahlung = downPaymentBruttolohn - downPaymentTotalAbzuege;

      newRows[7] = {
        ...newRows[7],
        beschreibung: 'Anzahlung (1-25)',
        menge: downPaymentHoursDecimal > 0 ? downPaymentHoursDecimal.toFixed(2) : '',
        einzelpreis: '',
        gesamt: anzahlung.toFixed(2),
      };

      // Restzahlung (id: 8)
      const restzahlung = nettolohn - anzahlung;
      newRows[8] = {
          ...newRows[8],
          beschreibung: 'Restzahlung',
          menge: (totalHoursDecimal - downPaymentHoursDecimal) > 0 ? (totalHoursDecimal - downPaymentHoursDecimal).toFixed(2) : '',
          einzelpreis: '',
          gesamt: restzahlung.toFixed(2),
      };

      return newRows;
    });
  }, [totalHoursDecimal, hourlyRate, grossSalary, downPaymentHoursDecimal]);
  
  // Daten für Jahresübersicht und Diagramm laden
  useEffect(() => {
    if (activeSheet === 'Jahres-Bilanz') {
        const year = currentDate.getFullYear();
        const summaryData: MonthSummary[] = [];

        for (let month = 0; month < 12; month++) {
            const date = new Date(year, month, 1);
            const key = getRowsKey(date);
            try {
                const savedRowsJSON = localStorage.getItem(key);
                if (savedRowsJSON) {
                    const savedRows: TimeSheetRow[] = JSON.parse(savedRowsJSON);
                    const totalMinutes = savedRows.reduce((acc, row) => acc + timeToMinutes(row.hours), 0);
                    const nettolohn = calculateMonthlyNettolohn(savedRows, hourlyRate, lohnRows);
                    summaryData.push({
                        hours: minutesToTime(totalMinutes),
                        salary: nettolohn
                    });
                } else {
                    summaryData.push({ hours: '00:00', salary: 0 });
                }
            } catch (e) {
                console.error(`Fehler beim Laden der Daten für ${year}-${month}`, e);
                summaryData.push({ hours: '00:00', salary: 0 });
            }
        }
        setYearlySummary(summaryData);
    }
  }, [activeSheet, currentDate, hourlyRate, lohnRows]);

  // Funktion zum Sichern der Daten des aktuellen Monats als JSON-Datei
  const handleBackup = () => {
    const dataStr = JSON.stringify(rows, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    const date = new Date(currentDate).toISOString().slice(0, 7); // YYYY-MM
    link.download = `arbeitszeiterfassung-backup-${date}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  // Funktion zum Auslösen des Datei-Inputs für das Laden
  const handleLoadBackupClick = () => {
    fileInputRef.current?.click();
  };

  // Funktion zum Verarbeiten der hochgeladenen Backup-Datei
  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const text = e.target?.result;
        if (typeof text !== 'string') {
          throw new Error("Datei konnte nicht als Text gelesen werden.");
        }
        const data = JSON.parse(text);

        if (!Array.isArray(data) || (data.length > 0 && typeof data[0].id === 'undefined')) {
          throw new Error("Ungültiges Backup-Format.");
        }
        
        setRows(data as TimeSheetRow[]);
        alert(`Backup für ${new Intl.DateTimeFormat('de-DE', { month: 'long', year: 'numeric' }).format(currentDate)} erfolgreich geladen!`);
      } catch (error) {
        console.error("Fehler beim Laden des Backups:", error);
        alert(`Fehler beim Laden des Backups: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`);
      }
    };
    reader.onerror = () => {
      alert("Fehler beim Lesen der Datei.");
    };
    reader.readAsText(file);
    event.target.value = ''; // Input zurücksetzen, um dieselbe Datei erneut laden zu können
  };

  return (
    <div className="container">
      <header>
        <h1>Arbeitszeiterfassung <span className="version-tag">V.2.1</span></h1>
        <div className="month-navigation">
            <button onClick={goToPreviousMonth} className="month-nav-btn" aria-label="Vorheriger Monat">&lt;</button>
            <span className="current-month">
                {new Intl.DateTimeFormat('de-DE', { month: 'long', year: 'numeric' }).format(currentDate)}
            </span>
            <button onClick={goToNextMonth} className="month-nav-btn" aria-label="Nächster Monat">&gt;</button>
        </div>
      </header>
      
      <nav className="sheet-nav">
          <button onClick={() => setActiveSheet('Zeiterfassung')} className={`sheet-nav-btn ${activeSheet === 'Zeiterfassung' ? 'active' : ''}`}>Zeiterfassung</button>
          <button onClick={() => setActiveSheet('Lohn')} className={`sheet-nav-btn ${activeSheet === 'Lohn' ? 'active' : ''}`}>Lohn</button>
          <button onClick={() => setActiveSheet('Jahres-Bilanz')} className={`sheet-nav-btn ${activeSheet === 'Jahres-Bilanz' ? 'active' : ''}`}>Jahres-Bilanz</button>
      </nav>

      <main>
        {activeSheet === 'Zeiterfassung' && (
          <div className="table-wrapper">
            <table aria-label="Arbeitszeittabelle">
              <thead>
                <tr>
                  <th>Datum</th>
                  <th>Tag</th>
                  <th>VM Start</th>
                  <th>VM Ende</th>
                  <th>NM Start</th>
                  <th>NM Ende</th>
                  <th>Pause</th>
                  <th>Stunden</th>
                </tr>
              </thead>
              <tbody>
                {rows.map((row) => (
                  <tr key={row.id} className={row.id === activeRowId ? 'active-row' : ''}>
                    <td><input type="text" className="date-input" value={row.date} onChange={e => handleInputChange(row.id, 'date', e.target.value)} onFocus={() => setActiveRowId(row.id)} aria-label={`Datum für Zeile ${row.id}`} readOnly /></td>
                    <td>{row.day}</td>
                    <td><input id={`vmStart-${row.id}`} type="text" className="time-input" value={row.vmStart} onChange={e => handleInputChange(row.id, 'vmStart', e.target.value)} onFocus={() => setActiveRowId(row.id)} aria-label={`Vormittag Start für Zeile ${row.id}`} /></td>
                    <td><input id={`vmEnd-${row.id}`} type="text" className="time-input" value={row.vmEnd} onChange={e => handleInputChange(row.id, 'vmEnd', e.target.value)} onFocus={() => setActiveRowId(row.id)} aria-label={`Vormittag Ende für Zeile ${row.id}`} /></td>
                    <td><input id={`nmStart-${row.id}`} type="text" className="time-input" value={row.nmStart} onChange={e => handleInputChange(row.id, 'nmStart', e.target.value)} onFocus={() => setActiveRowId(row.id)} aria-label={`Nachmittag Start für Zeile ${row.id}`} /></td>
                    <td><input id={`nmEnd-${row.id}`} type="text" className="time-input" value={row.nmEnd} onChange={e => handleInputChange(row.id, 'nmEnd', e.target.value)} onFocus={() => setActiveRowId(row.id)} onKeyDown={e => handleKeyDown(e, row.id)} aria-label={`Nachmittag Ende für Zeile ${row.id}`} /></td>
                    <td>{row.pause}</td>
                    <td>{row.hours}</td>
                  </tr>
                ))}
              </tbody>
              <tfoot>
                <tr>
                  <td className="footer-actions">
                    <button onClick={handleBackup} className="backup-btn">Backup</button>
                    <input type="file" ref={fileInputRef} onChange={handleFileChange} style={{ display: 'none' }} accept=".json" />
                    <button onClick={handleLoadBackupClick} className="backup-btn">Laden</button>
                  </td>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td></td>
                  <td className="total-label">Gesamtstunden:</td>
                  <td className="total-value">{totalHours}</td>
                </tr>
              </tfoot>
            </table>
          </div>
        )}
        {activeSheet === 'Lohn' && (
          <div className="sheet-content">
            <h2>Lohnberechnung</h2>
            
            <div className="table-wrapper lohn-table-wrapper">
              <table className="lohn-table" aria-label="Zusätzliche Lohnposten">
                <thead>
                  <tr>
                    <th></th>
                    <th>Ansatz 1</th>
                    <th>Ansatz 2</th>
                    <th>Total CHF</th>
                  </tr>
                </thead>
                <tbody>
                  {lohnRows.map((row) => (
                    <tr key={row.id} className={`${row.id === 3 ? 'bruttolohn-row' : ''} lohn-row-${row.id}`}>
                      <td>
                        <div className="ansatz-wrapper">
                          <input type="text" value={row.beschreibung} onChange={e => handleLohnInputChange(row.id, 'beschreibung', e.target.value)} aria-label={`Beschreibung für Zeile ${row.id}`} readOnly />
                           {([0, 1, 2, 3, 5, 6, 7, 8].some(id => id === row.id)) && (
                              <span className="beschreibung-unit">
                                {[0, 7, 8].includes(row.id) && 'Std.'}
                                {[1, 2, 3, 5, 6].includes(row.id) && 'CHF'}
                              </span>
                            )}
                        </div>
                      </td>
                      <td>
                        {![3, 6, 9].includes(row.id) &&
                          <input type="text" value={row.menge} onChange={e => handleLohnInputChange(row.id, 'menge', e.target.value)} aria-label={`Stunden für Zeile ${row.id}`} readOnly />
                        }
                      </td>
                      <td>
                        {![3, 6, 7, 8, 9].includes(row.id) &&
                          <div className="ansatz-wrapper">
                            <input type="text" value={row.einzelpreis} onChange={e => handleLohnInputChange(row.id, 'einzelpreis', e.target.value)} aria-label={`Ansatz für Zeile ${row.id}`} readOnly />
                            {row.id === 0 && <span className="currency-sign">CHF</span>}
                            {(row.id === 1 || row.id === 2 || row.id === 4 || row.id === 5) && <span className="percent-sign">%</span>}
                          </div>
                        }
                      </td>
                      <td className="calculated-total">{row.gesamt}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        )}
        {activeSheet === 'Jahres-Bilanz' && (
            <div className="sheet-content yearly-summary-locked">
                <h2>Jahres-Bilanz {currentDate.getFullYear()}</h2>
                <div className="year-grid">
                  {[
                    'Januar', 'Februar', 'März', 'April',
                    'Mai', 'Juni', 'Juli', 'August',
                    'September', 'Oktober', 'November', 'Dezember'
                  ].map((month, index) => {
                    const monthData = yearlySummary[index];
                    return (
                        <div key={month} className="month-container">
                          <h3>{month}</h3>
                          <div className="month-data">
                            <p>
                                <span>Stunden:</span>
                                <span>{monthData.hours}</span>
                            </p>
                            <p>
                                <span>Nettolohn:</span>
                                <span>{monthData.salary.toFixed(2)} CHF</span>
                            </p>
                          </div>
                        </div>
                    );
                  })}
                </div>
                <LineChart 
                    data={yearlySummary.map(s => s.salary)} 
                    labels={['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez']}
                />
            </div>
        )}
      </main>
    </div>
  );
};

const container = document.getElementById('root');
if (container) {
  const root = createRoot(container);
  root.render(<App />);
}